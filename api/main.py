from fastapi import FastAPI
from pydantic import BaseModel
from typing import TypedDict, Dict, List
from core.agent import run_agent
import pandas as pd
app = FastAPI(title="DB Agent API")

# Define Agent State Type
class AgentState(TypedDict):
    chat_history: List[str]
    user_query: str
    sql_query: str
    final_response: str


#âƒ£ In-memory state storage
user_states: Dict[str, AgentState] = {}


# Define Input Schema
class ChatRequest(BaseModel):
    session_id: str
    message: str


# Health check route
@app.get("/")
async def root():
    return {"message": "DB Agent is running ðŸš€"}


#Chat endpoint

@app.post("/chat")
async def chat_endpoint(request: ChatRequest):
    """
    Generate and execute an SQL query using the agent.
    """

    # Retrieve or initialize session state
    state = user_states.get(
        request.session_id,
        {"chat_history": [], "user_query": "", "sql_query": "", "final_response": ""}
    )

    # Update user query
    state["user_query"] = request.message
    state["chat_history"].append(request.message)

    try:
        # Define database schema context (for now, static)
        db_schema = """
        Tables:
        products(id, name, category, description)
        suppliers(id, name, city, address)
        purchases(id, product_id, supplier_id, purchase_date, quantity, unit_cost)
        sales(id, product_id, sale_date, quantity, unit_price)
        Relations:
        - purchases.product_id â†’ products.id
        - purchases.supplier_id â†’ suppliers.id
        - sales.product_id â†’ products.id
        """

        #  Call the agent
        df: pd.DataFrame = run_agent(request.message, db_schema)

        # Convert result to JSON-safe format
        result = df.head(10).to_dict(orient="records")

        # Update state
        state["sql_query"] = "Generated by agent"  # weâ€™ll update this later
        state["final_response"] = f"Found {len(df)} records"

        # Save state
        user_states[request.session_id] = state

        return {
            "session_id": request.session_id,
            "status": "success",
            "records": result,
            "state": state
        }

    except Exception as e:
        # Handle any runtime errors gracefully
        state["final_response"] = f"Error: {str(e)}"
        user_states[request.session_id] = state

        return {
            "session_id": request.session_id,
            "status": "error",
            "message": str(e),
            "state": state
        }
