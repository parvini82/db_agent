from fastapi import FastAPI
from pydantic import BaseModel
from typing import TypedDict, Dict, List, Optional
from core.agent import run_agent, run_agent_with_workflow
from core.workflow import ConversationTurn
import pandas as pd
app = FastAPI(title="DB Agent API")

# Define Agent State Type
class AgentState(TypedDict):
    chat_history: List[str]
    user_query: str
    sql_query: str
    final_response: str
    conversation_history: List[Dict[str, str]]  # For workflow memory


# In-memory state storage
user_states: Dict[str, AgentState] = {}


# Define Input Schema
class ChatRequest(BaseModel):
    session_id: str
    message: str
    use_workflow: bool = True  # Default to using workflow


# Health check route
@app.get("/")
async def root():
    return {"message": "DB Agent is running ðŸš€"}


#Chat endpoint

@app.post("/chat")
async def chat_endpoint(request: ChatRequest):
    """
    Generate and execute an SQL query using the agent.
    """

    # Retrieve or initialize session state
    state = user_states.get(
        request.session_id,
        {"chat_history": [], "user_query": "", "sql_query": "", "final_response": ""}
    )

    # Update user query
    state["user_query"] = request.message
    state["chat_history"].append(request.message)

    try:
        if request.use_workflow:
            # Use workflow agent with memory
            conversation_history = []
            if state.get("conversation_history"):
                # Convert stored history back to ConversationTurn objects
                conversation_history = [
                    ConversationTurn(
                        question=h["question"],
                        sql_query=h["sql_query"],
                        result_summary=h["result_summary"],
                        answer=h["answer"],
                        timestamp=h["timestamp"]
                    )
                    for h in state["conversation_history"]
                ]
            
            result = run_agent_with_workflow(request.message, conversation_history)
            
            # Update state with workflow results
            state["sql_query"] = result.get("sql_query", "")
            state["final_response"] = result.get("response", "")
            
            # Store conversation history as dictionaries for JSON serialization
            state["conversation_history"] = [
                {
                    "question": turn.question,
                    "sql_query": turn.sql_query,
                    "result_summary": turn.result_summary,
                    "answer": turn.answer,
                    "timestamp": turn.timestamp
                }
                for turn in result.get("conversation_history", [])
            ]
            
            # Convert query result to JSON-safe format
            records = []
            if result.get("query_result") is not None:
                records = result["query_result"].head(10).to_dict(orient="records")
            
            # Save state
            user_states[request.session_id] = state

            return {
                "session_id": request.session_id,
                "status": "success",
                "records": records,
                "sql_query": result.get("sql_query", ""),
                "response": result.get("response", ""),
                "context_used": result.get("context_used", ""),
                "error": result.get("error"),
                "conversation_history": state["conversation_history"],
                "state": state
            }
        else:
            # Use simple agent (backward compatibility)
            df: pd.DataFrame = run_agent(request.message)

            # Convert result to JSON-safe format
            result = df.head(10).to_dict(orient="records")

            # Update state
            state["sql_query"] = "Generated by simple agent"
            state["final_response"] = f"Found {len(df)} records"

            # Save state
            user_states[request.session_id] = state

            return {
                "session_id": request.session_id,
                "status": "success",
                "records": result,
                "state": state
            }

    except Exception as e:
        # Handle any runtime errors gracefully
        state["final_response"] = f"Error: {str(e)}"
        user_states[request.session_id] = state

        return {
            "session_id": request.session_id,
            "status": "error",
            "message": str(e),
            "state": state
        }


# Workflow-specific endpoint
@app.post("/chat/workflow")
async def chat_workflow_endpoint(request: ChatRequest):
    """
    Chat endpoint specifically for LangGraph workflow with conversation memory.
    """
    
    # Retrieve or initialize session state
    state = user_states.get(
        request.session_id,
        {
            "chat_history": [], 
            "user_query": "", 
            "sql_query": "", 
            "final_response": "",
            "conversation_history": []
        }
    )

    # Update user query
    state["user_query"] = request.message
    state["chat_history"].append(request.message)

    try:
        # Use workflow agent with memory
        conversation_history = []
        if state.get("conversation_history"):
            # Convert stored history back to ConversationTurn objects
            conversation_history = [
                ConversationTurn(
                    question=h["question"],
                    sql_query=h["sql_query"],
                    result_summary=h["result_summary"],
                    answer=h["answer"],
                    timestamp=h["timestamp"]
                )
                for h in state["conversation_history"]
            ]
        
        result = run_agent_with_workflow(request.message, conversation_history)
        
        # Update state with workflow results
        state["sql_query"] = result.get("sql_query", "")
        state["final_response"] = result.get("response", "")
        
        # Store conversation history as dictionaries for JSON serialization
        state["conversation_history"] = [
            {
                "question": turn.question,
                "sql_query": turn.sql_query,
                "result_summary": turn.result_summary,
                "answer": turn.answer,
                "timestamp": turn.timestamp
            }
            for turn in result.get("conversation_history", [])
        ]
        
        # Convert query result to JSON-safe format
        records = []
        if result.get("query_result") is not None:
            records = result["query_result"].head(10).to_dict(orient="records")
        
        # Save state
        user_states[request.session_id] = state

        return {
            "session_id": request.session_id,
            "status": "success",
            "records": records,
            "sql_query": result.get("sql_query", ""),
            "response": result.get("response", ""),
            "context_used": result.get("context_used", ""),
            "error": result.get("error"),
            "conversation_history": state["conversation_history"],
            "state": state
        }

    except Exception as e:
        # Handle any runtime errors gracefully
        state["final_response"] = f"Error: {str(e)}"
        user_states[request.session_id] = state

        return {
            "session_id": request.session_id,
            "status": "error",
            "message": str(e),
            "state": state
        }


# Endpoint to get conversation history
@app.get("/chat/history/{session_id}")
async def get_conversation_history(session_id: str):
    """
    Get conversation history for a session.
    """
    state = user_states.get(session_id)
    if not state:
        return {"error": "Session not found"}
    
    return {
        "session_id": session_id,
        "conversation_history": state.get("conversation_history", []),
        "chat_history": state.get("chat_history", [])
    }


# Endpoint to clear conversation history
@app.delete("/chat/history/{session_id}")
async def clear_conversation_history(session_id: str):
    """
    Clear conversation history for a session.
    """
    if session_id in user_states:
        user_states[session_id]["conversation_history"] = []
        user_states[session_id]["chat_history"] = []
        return {"message": "Conversation history cleared", "session_id": session_id}
    else:
        return {"error": "Session not found"}
